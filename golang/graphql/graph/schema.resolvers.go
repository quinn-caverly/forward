package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"encoding/base64"
	"fmt"
	"math/rand"
	"net/rpc"
	"time"

	"github.com/quinn-caverly/forward-graphql/graph/model"
	"github.com/quinn-caverly/forward-graphql/internal/db"
	"github.com/quinn-caverly/forward-utils/endpointstructs"
	"go.mongodb.org/mongo-driver/bson"
)

// GetProductByID is the resolver for the getProductById field.
func (r *queryResolver) GetProductByID(ctx context.Context, id string) (*model.ProductDisplayContainer, error) {
    client, err := rpc.Dial("tcp", "go-product-builder-service:8080")
	if err != nil {
		return nil, err
	}
	defer client.Close()

	reply := endpointstructs.ProductDisplayContainer{}

	err = client.Call("BuildProduct.Read", endpointstructs.UniqueProductIdentifier{Brand: "stussy", Id: id}, &reply)
	if err != nil {
		return nil, err
	}

	uniqueProduct := model.UniqueProduct{ID: reply.Up.Id, Brand: reply.Up.Brand, Name: reply.Up.Name,
		URLOnBrandSite: reply.Up.UrlOnBrandSite, Price: reply.Up.Price, Description: reply.Up.Description,
		ClothingType: reply.Up.ClothingType}

	colorContainers := []*model.ColorContainer{}
	for i := range reply.ColorContainers {
		cur := model.ColorContainer{ColorName: reply.ColorContainers[i].ColorAttr.ColorName,
			DateScraped: reply.ColorContainers[i].ColorAttr.DateScraped}

		strEncodedImgs := []string{}
		imgs := reply.ColorContainers[i].ImageBytes
		for _, img := range imgs {
			encodedStr := base64.StdEncoding.EncodeToString(img)
			strEncodedImgs = append(strEncodedImgs, encodedStr)
		}

		cur.ImageBytes = strEncodedImgs
		colorContainers = append(colorContainers, &cur)
	}

	ret := model.ProductDisplayContainer{Up: &uniqueProduct, ColorContainers: colorContainers}
	return &ret, nil
}

// CountUsableProducts is the resolver for the countUsableProducts field.
func (r *queryResolver) CountUsableProducts(ctx context.Context) (int, error) {
	coll := db.GetStussyColl()
	ans, err := coll.CountDocuments(ctx, bson.M{})

	return int(ans), err
}

// GenerateRandomProds is the resolver for the generateRandomProds field.
func (r *queryResolver) GenerateRandomProds(ctx context.Context, num int) ([]string, error) {
	coll := db.GetStussyColl()

	// projection := bson.M{"Id": 1}
	cursor, err := coll.Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	ids := []string{}
	for cursor.Next(ctx) {
		var result bson.M
		if err := cursor.Decode(&result); err != nil {
			return nil, err
		}

		fieldValue, found := result["_id"]
		if !found {
			return nil, err
		}

		fmt.Println(fieldValue)

		stringVal, ok := fieldValue.(string)
		if !ok {
			return nil, err
		}

		ids = append(ids, stringVal)
	}

	rand.Seed(time.Now().UnixNano())

	rand.Shuffle(len(ids), func(i, j int) {
		ids[i], ids[j] = ids[j], ids[i]
	})

	return ids[:num], nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
